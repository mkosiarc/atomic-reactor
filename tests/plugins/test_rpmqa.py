"""
Copyright (c) 2015 Red Hat, Inc
All rights reserved.

This software may be modified and distributed under the terms
of the BSD license. See the LICENSE file for details.
"""

import docker
from flexmock import flexmock
import pytest
import tarfile
from functools import partial
import subprocess

from atomic_reactor.inner import DockerBuildWorkflow
from atomic_reactor.plugin import PostBuildPluginsRunner, PluginFailedException
from atomic_reactor.plugins.post_rpmqa import (PostBuildRPMqaPlugin, RPMDB_DIR_NAME, RPMDB_PATH)
from atomic_reactor.utils.rpm import parse_rpm_output
from tests.constants import DOCKERFILE_GIT
from tests.docker_mock import mock_docker
from tests.stubs import StubInsideBuilder, StubSource
from docker.errors import APIError

TEST_IMAGE = "fedora:latest"
SOURCE = {"provider": "git", "uri": DOCKERFILE_GIT}


PACKAGE_LIST = ['python-docker-py;1.3.1;1.fc24;noarch;(none);'
                '191456;7c1f60d8cde73e97a45e0c489f4a3b26;1438058212;(none);(none)',
                'fedora-repos-rawhide;24;0.1;noarch;(none);'
                '2149;d41df1e059544d906363605d47477e60;1436940126;(none);(none)',
                'gpg-pubkey-doc;1.0;1;noarch;(none);'
                '1000;00000000000000000000000000000000;1436940126;(none);(none)']
PACKAGE_LIST_WITH_AUTOGENERATED = PACKAGE_LIST + ['gpg-pubkey;qwe123;zxcasd123;(none);(none);0;'
                                                  '(none);1370645731;(none);(none)']
PACKAGE_LIST_WITH_AUTOGENERATED_B = [x.encode("utf-8") for x in PACKAGE_LIST_WITH_AUTOGENERATED]


pytestmark = pytest.mark.usefixtures('user_params')


def generate_archive(tmpdir, rpm_dir_exists=True, rpm_dir_empty=False):
    """Generate a fake tar archive
    :param bool rpm_dir_exists: wheter the archive contains rpm db directory.
    :param bool rpm_dir_empty: whether the rpm db directory in archive is empty.
    :rtype: generator
    """
    archive_path = tmpdir.join('temp.tar')
    if rpm_dir_exists:
        rpm_dir = tmpdir.join(RPMDB_DIR_NAME).mkdir()
        if not rpm_dir_empty:
            rpm_dir.join('Basenames').write('')
            rpm_dir.join('Dirnames').write('')
            rpm_dir.join('Packages').write('')

        with tarfile.open(str(archive_path), 'w') as archive_tar:
            archive_tar.add(rpm_dir, arcname=RPMDB_DIR_NAME)
    else:
        non_rpm_dir = tmpdir.join('non_rpm_dir').mkdir()
        with tarfile.open(str(archive_path), 'w') as archive_tar:
            archive_tar.add(non_rpm_dir, arcname='non_rpm_dir')

    with open(str(archive_path), 'rb') as f:
        for block in iter(partial(f.read, 8), b''):
            yield block
    archive_path.remove()


def mock_logs(cid, **kwargs):
    return b"\n".join(PACKAGE_LIST_WITH_AUTOGENERATED_B)


def mock_logs_raise(cid, **kwargs):
    raise RuntimeError


def mock_logs_empty(cid, **kwargs):
    return ''


def setup_mock_logs_retry(cache=None):
    cache = cache or {}
    cache.setdefault('attempt', 0)

    def mock_logs_retry(cid, **kwargs):
        if cache['attempt'] < 4:
            logs = mock_logs_empty(cid, **kwargs)
        else:
            logs = mock_logs(cid, **kwargs)

        cache['attempt'] += 1
        return logs

    return mock_logs_retry


def get_builder(workflow, base_from_scratch=False):
    workflow.builder = StubInsideBuilder().for_workflow(workflow)
    if base_from_scratch:
        workflow.builder.set_dockerfile_images(['scratch'])
    else:
        workflow.builder.set_dockerfile_images([])
    return workflow.builder


@pytest.mark.parametrize('base_from_scratch', [
    True,
    False,
])
@pytest.mark.parametrize("ignore_autogenerated", [
    {"ignore": True, "package_list": PACKAGE_LIST},
    {"ignore": False, "package_list": PACKAGE_LIST_WITH_AUTOGENERATED},
])
def test_rpmqa_plugin_success(caplog, tmpdir, docker_tasker, base_from_scratch,
                              ignore_autogenerated):
    mock_docker()
    workflow = DockerBuildWorkflow(source=SOURCE)
    workflow.source = StubSource()
    workflow.builder = get_builder(workflow, base_from_scratch=base_from_scratch)

    mock_stream = generate_archive(tmpdir)

    (flexmock(docker_tasker.tasker.d.wrapped)
     .should_receive('get_archive')
     .and_return(mock_stream, {}))

    (flexmock(subprocess)
     .should_receive("check_output")
     .once()
     .and_return("\n".join(PACKAGE_LIST_WITH_AUTOGENERATED)))

    flexmock(docker.APIClient, logs=mock_logs)
    runner = PostBuildPluginsRunner(
        docker_tasker,
        workflow,
        [{"name": PostBuildRPMqaPlugin.key,
          "args": {
              'image_id': TEST_IMAGE,
              "ignore_autogenerated_gpg_keys": ignore_autogenerated["ignore"]}}
         ])
    results = runner.run()

    assert results[PostBuildRPMqaPlugin.key] == ignore_autogenerated["package_list"]
    assert workflow.image_components == parse_rpm_output(ignore_autogenerated["package_list"])


@pytest.mark.parametrize('base_from_scratch', [
    True,
    False,
])
def test_rpmqa_plugin_rpm_query_failed(caplog, tmpdir, docker_tasker, base_from_scratch):
    mock_docker()
    workflow = DockerBuildWorkflow(source=SOURCE)
    workflow.source = StubSource()
    workflow.builder = get_builder(workflow, base_from_scratch=base_from_scratch)

    mock_stream = generate_archive(tmpdir)

    (flexmock(docker_tasker.tasker.d.wrapped)
     .should_receive('get_archive')
     .and_return(mock_stream, {}))

    runner = PostBuildPluginsRunner(
        docker_tasker,
        workflow,
        [{"name": PostBuildRPMqaPlugin.key,
          "args": {
              'image_id': TEST_IMAGE,
              "ignore_autogenerated_gpg_keys": True}}
         ])

    log_msg_getting = 'getting rpms from rpmdb:'

    (flexmock(subprocess)
     .should_receive("check_output")
     .once()
     .and_raise(Exception, 'rpm query failed'))

    with pytest.raises(Exception, match='rpm query failed'):
        runner.run()
    assert log_msg_getting in caplog.text
    assert workflow.image_components is None
    log_msg = 'Failed to get rpms from rpmdb:'
    assert log_msg in caplog.text


@pytest.mark.parametrize('base_from_scratch', [
    True,
    False,
])
def test_rpmqa_plugin_rpmdb_dir_is_empty(
    caplog, tmpdir, docker_tasker,
    base_from_scratch,
):
    mock_docker()
    workflow = DockerBuildWorkflow(source=SOURCE)
    workflow.source = StubSource()
    workflow.builder = get_builder(workflow, base_from_scratch=base_from_scratch)

    mock_stream = generate_archive(
        tmpdir, rpm_dir_empty=True
    )

    (flexmock(docker_tasker.tasker.d.wrapped)
     .should_receive('get_archive')
     .and_return(mock_stream, {}))

    runner = PostBuildPluginsRunner(
        docker_tasker,
        workflow,
        [{"name": PostBuildRPMqaPlugin.key,
          "args": {
              'image_id': TEST_IMAGE,
              "ignore_autogenerated_gpg_keys": True}}
         ])

    log_msg = f'rpmdb directory {RPMDB_PATH} is empty'
    if base_from_scratch:
        results = runner.run()
        assert log_msg in caplog.text
        assert results[PostBuildRPMqaPlugin.key] is None
        assert workflow.image_components is None
    else:
        with pytest.raises(PluginFailedException, match=log_msg):
            runner.run()
        assert log_msg in caplog.text
        assert workflow.image_components is None


@pytest.mark.parametrize('base_from_scratch', [
    True,
    False,
])
@pytest.mark.parametrize('get_archive_raises', [APIError, Exception])
def test_rpmqa_plugin_get_archive_fails(caplog, tmpdir, docker_tasker, base_from_scratch,
                                        get_archive_raises):
    mock_docker()
    workflow = DockerBuildWorkflow(source=SOURCE)
    workflow.source = StubSource()
    workflow.builder = get_builder(workflow, base_from_scratch=base_from_scratch)

    runner = PostBuildPluginsRunner(
        docker_tasker,
        workflow,
        [{"name": PostBuildRPMqaPlugin.key,
          "args": {
              'image_id': TEST_IMAGE,
              "ignore_autogenerated_gpg_keys": True}}
         ])

    response = flexmock(content="abc", status_code=123)
    (flexmock(docker_tasker.tasker.d.wrapped)
     .should_receive('get_archive')
     .and_raise(get_archive_raises, 'get archive failed', response))

    if get_archive_raises == APIError:
        log_msg = 'Could not extract rpmdb in'
        if base_from_scratch:
            results = runner.run()
            assert log_msg in caplog.text
            assert results[PostBuildRPMqaPlugin.key] is None
            assert workflow.image_components is None
        else:
            with pytest.raises(PluginFailedException):
                runner.run()
            assert log_msg in caplog.text
            assert workflow.image_components is None

    elif get_archive_raises == Exception:
        with pytest.raises(Exception, match='get archive failed'):
            runner.run()
        log_msg = 'Get archive failed while extracting rpmdb in'
        assert log_msg in caplog.text
        assert workflow.image_components is None


def test_rpmqa_plugin_skip(docker_tasker):  # noqa
    """
    Test skipping the plugin if workflow.image_components is already set
    """
    mock_docker()
    workflow = DockerBuildWorkflow(source=SOURCE)
    workflow.source = StubSource()
    workflow.builder = get_builder(workflow)

    image_components = {
        'type': 'rpm',
        'name': 'something'
    }
    setattr(workflow, 'image_components', image_components)

    flexmock(docker.APIClient, logs=mock_logs_raise)
    runner = PostBuildPluginsRunner(docker_tasker, workflow,
                                    [{"name": PostBuildRPMqaPlugin.key,
                                      "args": {'image_id': TEST_IMAGE}}])
    results = runner.run()
    assert results[PostBuildRPMqaPlugin.key] is None
    assert workflow.image_components == image_components


def test_rpmqa_plugin_exception(docker_tasker):  # noqa
    mock_docker()
    workflow = DockerBuildWorkflow(source=SOURCE)
    workflow.source = StubSource()
    workflow.builder = get_builder(workflow)

    flexmock(docker.APIClient, logs=mock_logs_raise)
    runner = PostBuildPluginsRunner(docker_tasker, workflow,
                                    [{"name": PostBuildRPMqaPlugin.key,
                                      "args": {'image_id': TEST_IMAGE}}])
    with pytest.raises(PluginFailedException):
        runner.run()
